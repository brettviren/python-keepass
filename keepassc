#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Command line interface to manipulating keepass files
'''
import sys


class Cli(object):
    '''
    Process command line
    '''

    commands = [
        'help',                 # print help message
        'open',                 # open and decrypt a file
        'save',                 # save current DB to file
        'dump',                 # dump current DB to text
        'entry',                # add an entry
        ]

    def __init__(self,args=None):
        self.db = None
        self.hier = None
        self.command_line = None
        self.ops = {}
        self.masterkey = None
        if args:
            self.parse_args(args)

    def parse_args(self,args):
        '''
        keepass.cli [options] [cmd [options]] [...]

        The command line consists of general options followed by zero
        or more commands and their options.

        '''

        def splitopts(argv):
            'Split optional command and its args removing them from input'
            if not argv: return None

            cmd=""
            if argv[0][0] != '-':
                if argv[0] not in Cli.commands:
                    raise ValueError,'Unknown command: "%s"'%argv[0]
                cmd = argv.pop(0)
                pass
            copy = list(argv)
            cmdopts = []
            for arg in copy:
                if arg in Cli.commands: break
                cmdopts.append(argv.pop(0))
                continue
            return [cmd,cmdopts]

        cmdline = []
        copy = list(args)
        while copy:
            chunk = splitopts(copy)
            if not chunk: break
            if not chunk[0]: chunk[0] = 'general'
            meth = eval('self._%s_op'%chunk[0])
            self.ops[chunk[0]] = meth()
            cmdline.append(chunk)
        self.command_line = cmdline

    def run(self):
        'Process commands'
        if not self.command_line:
            print self._general_op().print_help()
            return
        for cmd,cmdopts in self.command_line:
            meth = eval('self._%s'%cmd)
            meth(cmdopts)

    def _general_op(self):
        '''
        keepassc [options] [cmd cmd_options] ...
        
        Example: open, dump to screen and save

        keepassc open input.kpdb \
                 dump -f '"%(title)s" "%(username)s" %(url)s' \
                 save output.kpdb

        execute "help" command for more information.
        '''
        from optparse import OptionParser
        return OptionParser(usage=self._general_op.__doc__)

    def _general(self,opts):
        'Process general options'
        opts,args = self.ops['general'].parse_args(opts)

    def _help_op(self):
        pass

    def _help(self,opts):
        'Print some helpful information'
        print 'Available commands:'
        for cmd in Cli.commands:
            meth = eval('self._%s'%cmd)
            print '\t%s: %s'%(cmd,meth.__doc__)
        print '\nPer-command help:\n'
        for cmd in Cli.commands:
            meth = eval('self._%s_op'%cmd)
            op = meth()
            if not op:
                continue
            print '%s'%cmd.upper()
            op.print_help()
            print

    def _open_op(self):
        'open [options] filename'
        from optparse import OptionParser
        return OptionParser(usage=self._open_op.__doc__,add_help_option=False)

    def _open(self,opts):
        'Read a file to the in-memory database'
        opts,files = self.ops['open'].parse_args(opts)
        if not files:
            print "No database file specified"
            sys.exit(1)
        from keepasslib import kpdb
        self.db = kpdb.Database(files[0], self.get_masterkey())
        self.hier = self.db.hierarchy()

    def _save_op(self):
        'save [options] filename'
        from optparse import OptionParser
        return OptionParser(usage=self._save_op.__doc__,add_help_option=False)

    def _save(self,opts):
        'Save the current in-memory database to a file'
        opts, files = self.ops['save'].parse_args(opts)
        self.db.update(self.hier)
        self.db.write(files[0], self.get_masterkey())

    def _dump_op(self):
        'dump [options] [name|/group/name]'
        from optparse import OptionParser
        op = OptionParser(usage=self._dump_op.__doc__,add_help_option=False)
        op.add_option('-p','--show-passwords',action='store_true',default=False,
                      help='Show passwords as plain text')
        op.add_option('-f','--format',type='string',
                      default='%(group_name)s/%(username)s: %(title)s %(url)s',
                      help='Set the format of the dump')
        return op

    def _dump(self,opts):
        'Print the current database in a formatted way.'
        opts,files = self.ops['dump'].parse_args(opts)
        if not self.hier:
            sys.stderr.write('Can not dump.  No database open.\n')
            return
        print self.hier
        #self.hier.dump(opts.format,opts.show_passwords)

    def _entry_op(self):
        'entry [options] username'
        from optparse import OptionParser
        op = OptionParser(usage=self._entry_op.__doc__,add_help_option=False)
        op.add_option('-p','--path',type='string',default='/',
                      help='Set folder path in which to store this entry')
        op.add_option('-t','--title',type='string',default="",
                      help='Set the title for the entry, defaults to username')
        op.add_option('-u','--url',type='string',default="",
                      help='Set a URL for the entry')
        op.add_option('-n','--note',type='string',default="",
                      help='Set a note for the entry')
        op.add_option('-i','--imageid',type='int',default=1,
                      help='Set the image ID number for the entry')
        op.add_option('-a','--append',action='store_true',default=False,
                      help='The entry will be appended instead of overriding matching entry')
        return op

    def _entry(self,opts):
        'Add an entry into the database'
        opts,args = self.ops['entry'].parse_args(opts)
        username = args[0]
        password = get_password('Keepass entry password', twice=True)
        self.db.add_entry(opts.path,opts.title or username,username,password,
                          opts.url,opts.note,opts.imageid,opts.append)

    def get_masterkey(self):
        """Get masterkey, asking for password if not set."""
        if self.masterkey is None:
            self.masterkey = get_password('Keepass masterkey')
        return self.masterkey


def get_password(prompt, twice=False):
    """Get password with getpass(), asking for it twice if needed."""
    import getpass
    password1 = None
    if twice:
        password2 = None
        while password1 is None or (password1 != password2):
            password1 = getpass.getpass(prompt+': ')
            password2 = getpass.getpass(prompt+' (again):')
            if password1 != password2:
                sys.stderr.write("Error: Your passwords didn't match\n")
    else:
        password1 = getpass.getpass(prompt+': ')
    return password1


def main(args):
    cliobj = Cli(args)
    cliobj.run()


if __name__ == '__main__':
    main(sys.argv[1:])
